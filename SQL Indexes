# Impact of Missing Indexes

A concise guide that explains the impact of missing indexes, how to detect them, and practical remediation steps. Designed to display well on GitHub (README / docs).

---

## Summary (Short answer)
- Missing indexes force full table scans, increasing latency, I/O, CPU, and memory usage.
- They increase lock durations and contention, slow joins, and can lead to replication lag, timeouts, and outages.
- As table size grows, these costs growâ€”often non-linearly.

---

## Why this happens (what the database does)
- Full table scans: Without an index, the engine inspects every row for WHERE, JOIN, ORDER BY, or GROUP BY conditions.
- More I/O and CPU: Scans read many more pages from disk and evict cached pages.
- Longer locks / contention: Long scans hold locks or consume worker threads longer, increasing blocking.
- Poor join strategies: Missing join-key indexes can force nested-loop scans or expensive hash joins.
- Higher memory/temp usage: Sorting or grouping without usable indexes may spill to disk.
- Cascading effects: Slow queries cause connection pileups, increased queueing, and replication lag.

---

## Concrete symptoms to watch for
- Long or growing latencies for specific statements.
- High logical reads / page reads in query plans.
- Sequential scans (seq scan / Table Scan) reported by EXPLAIN / EXPLAIN ANALYZE.
- High rows_examined (MySQL) or similar metrics.
- Lock waits and blocking sessions tied to long-running reads.
- Slow JOINs where join keys lack indexes.
- Replication lag or timeouts during peak loads.

---

## How to detect missing or inefficient indexes
- Use EXPLAIN / EXPLAIN ANALYZE (Postgres), EXPLAIN (MySQL), or Query Plan (SQL Server).
- Postgres: check `pg_stat_user_tables` (seq_scan) and `pg_stat_statements`.
- SQL Server: inspect `sys.dm_db_missing_index*` DMVs.
- MySQL: use the slow query log and `EXPLAIN` to inspect `rows_examined`.
-
