# SQL Indexes

A concise, well-formatted reference on SQL indexes for GitHub README/docs. This file explains the impact of missing indexes, index types, naming conventions, creation examples (Postgres, MySQL, SQL Server), and best practices for monitoring and maintenance.

---

## Impact of missing indexes

Missing indexes can severely affect query performance, especially as data grows.

- Slow queries: Without indexes, reads often become full table scans — the database must inspect every row to find matches. As table size grows, query latency and I/O increase dramatically.
- Locking and concurrency issues: Long-running full scans hold resources longer and increase contention, sometimes causing blocking or escalated locks that affect other queries.
- Inefficient joins: Joins without indexes on join keys force expensive operations (large nested loops or hash joins), increasing CPU, memory, and I/O.
- Poor user experience: Slow queries lead to slow page loads, timeouts, and application stalls.
- Operational impacts: Replication lag, connection pileups, timeouts, and degraded backups or monitoring can follow from sustained heavy scans.

---

## Quick summary

- Index columns used in WHERE, JOIN, ORDER BY, and GROUP BY.
- Prefer composite indexes when queries filter on multiple columns consistently.
- Use covering indexes to avoid touching the base table when possible.
- Avoid low-selectivity and redundant indexes — they hurt write performance and increase storage.
- Create indexes CONCURRENTLY / ONLINE in production where supported.

---

## Common index types

- B-tree: Default; good for equality and range queries.
- Hash: Equality-only (limited support across DB engines).
- GIN / GiST (Postgres): Good for full-text search, arrays, JSONB, and geometric data.
- BRIN (Postgres): For extremely large, naturally ordered tables (e.g., time-series) — tiny footprint.
- Filtered / Partial indexes: Index only a subset of rows (Postgres partial index, SQL Server filtered index).

---

## Naming conventions (recommended)

- Prefix: `idx_` or `ix_`
- Pattern: `idx_<table>_<col1>[_<col2>...]`
- Examples: `idx_users_email`, `ix_orders_customerid_createdat`

---

## Design guidance

- Index WHERE, JOIN, ORDER BY, GROUP BY columns used frequently.
- Use composite indexes for multi-column filters; ordering matters — put the most selective / commonly filtered column first.
- Covering indexes: include non-key columns (SQL Server `INCLUDE` or carefully chosen composite indexes) so queries can be answered from the index only.
- Use expression indexes for predicates that use functions (e.g., `LOWER(email)`).
- Use partial/filtered indexes when predicates are selective (e.g., `WHERE status = 'active'`).
- Balance read gains vs write costs — each index adds overhead to INSERT/UPDATE/DELETE.
- Drop unused indexes; they cost writes and storage.

---

## How to detect missing or inefficient indexes

- Run EXPLAIN / EXPLAIN ANALYZE (Postgres), EXPLAIN (MySQL), or View Query Plan (SQL Server).
  - Look for sequential scans / table scans / high `rows_examined` / high logical reads.
- Postgres:
  - `pg_stat_user_tables` (check `seq_scan`).
  - `pg_stat_statements` to find heavy queries.
- MySQL:
  - Slow query log and `EXPLAIN` (check `rows_examined`).
- SQL Server:
  - `sys.dm_db_missing_index_details*` DMVs for hints.
  - `sys.dm_db_index_usage_stats` to find unused indexes.
- APM/tracing: identify slow endpoints and the underlying SQL.

---

## Examples — create indexes safely

Postgres
```sql
-- Check query plan
EXPLAIN ANALYZE SELECT id, name FROM users WHERE email = 'user@example.com';

-- Create a non-blocking index in production
CREATE INDEX CONCURRENTLY idx_users_email ON users (email);

-- Composite index example (user_id, created_at)
CREATE INDEX CONCURRENTLY idx_orders_userid_createdat ON orders (user_id, created_at);

-- Expression index (case-insensitive search)
CREATE INDEX CONCURRENTLY idx_users_lower_email ON users (LOWER(email));

-- Partial index for selective subset
CREATE INDEX CONCURRENTLY idx_tasks_active_assigned ON tasks (assigned_to) WHERE status = 'active';
```

MySQL (InnoDB)
```sql
-- Inspect plan
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- Single-column index
CREATE INDEX idx_orders_customer_id ON orders (customer_id);

-- Composite index (leftmost column is used first)
CREATE INDEX idx_logs_level_created ON logs (level, created_at);
```

SQL Server
```sql
-- Check missing index suggestions (DMVs)
SELECT * FROM sys.dm_db_missing_index_details;

-- Create index online (reduces locks; requires supported edition)
CREATE INDEX IX_orders_customerid ON dbo.orders (customer_id) WITH (ONLINE = ON);

-- Filtered index (SQL Server)
CREATE INDEX IX_tasks_active_assigned ON dbo.tasks (assigned_to) WHERE status = 'active';
```

---

## Covering indexes

A covering index contains all columns needed by the query so the database can satisfy the query using only the index.

Postgres (design the index to include all needed columns in key order):
```sql
-- Make queries that filter on user_id and status, and select total, created_at.
CREATE INDEX CONCURRENTLY idx_orders_userid_status_created ON orders (user_id, status, created_at);
```

SQL Server (explicit include for non-key columns):
```sql
CREATE INDEX IX_orders_userid_status ON dbo.orders (user_id, status) INCLUDE (total, created_at);
```

---

## Indexes for JOINs

Always index join keys: foreign keys on the child table and primary keys on the parent table. This drastically improves join performance.

```sql
ALTER TABLE orders
  ADD CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id) REFERENCES customers(id);

CREATE INDEX idx_orders_customer_id ON orders (customer_id);
-- customers.id should be the primary key (and already indexed)
```

---

## Maintenance & statistics

- Update statistics regularly: `ANALYZE` (Postgres), `ANALYZE TABLE` (MySQL), `UPDATE STATISTICS` (SQL Server).
- Rebuild / REINDEX when indexes are bloated:
  - Postgres: `REINDEX` / `REINDEX CONCURRENTLY` (newer versions).
  - SQL Server: `ALTER INDEX ... REBUILD` or `REORGANIZE`.
- Monitor fragmentation and index usage; drop unused indexes to reduce write cost.

---

## Checklist to fix slow queries caused by missing indexes

1. Identify slow queries (APM, slow logs, pg_stat_statements).
2. Run EXPLAIN / EXPLAIN ANALYZE for candidate queries.
3. Find columns used in WHERE, JOIN, ORDER BY, GROUP BY — propose index(es).
4. Create index(es) using CONCURRENTLY / ONLINE in production where possible.
5. Re-run EXPLAIN ANALYZE and measure improvements (latency, logical reads).
6. Monitor write throughput and storage after index changes.
7. Remove redundant or unused indexes.
8. Consider partitioning, materialized views, or caching for very large workloads.

---

## Example workflow (Postgres) — end-to-end

1. Find heavy query:
```sql
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;
```

2. Inspect plan:
```sql
EXPLAIN ANALYZE SELECT id, name FROM users WHERE email = 'a@example.com';
-- if shows seq scan, consider an index
```

3. Create index safely:
```sql
CREATE INDEX CONCURRENTLY idx_users_email ON users (email);
```

4. Validate:
```sql
EXPLAIN ANALYZE SELECT id, name FROM users WHERE email = 'a@example.com';
-- should show an Index Scan and lower actual time
```

---

## Final tips

- Make index decisions based on real metrics and plans, not guesswork.
- Prefer fewer, well-designed indexes over many small ones.
- Document the intent of each index (why it exists) in schema docs or commit messages.
- Combine indexing with partitioning, caching, and query rewrites to achieve scalable performance.
